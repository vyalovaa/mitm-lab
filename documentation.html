<!DOCTYPE html>
<html lang="ru">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<title>Методическое пособие / Лабораторная работа. Человек посередине</title>
		<meta name="description" content="SQL Injection Lab">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<link href="css/bootstrap.min.css" rel="stylesheet">

		<style>
			h4 {
				margin-top: 25px;
			}
			h5 {
				margin-top: 15px;
			}
			.nav-inner {
				margin-left: 10px;
			}
			.demo-slot {
				color: #EE0000;
			}
			.callout { 
				border-left: 5px solid #EEEEEE;
				margin: 20px 0px;
				padding: 15px 30px 15px 15px;
			}
			.callout-info { 
				background-color: #F0F7FD;
				border-color: #D0E3F0;
			}
			figure.img {
				margin: 0;
				text-align: center;
			}
			figure.img img {  <!--/* изображение уменьшается пропорционально экрану браузера */-->
				max-width: 100%;
				height: auto;
			}
			figure.img figcaption {  <!--/* стиль описания */-->
				padding: 0 1%;
				font: italic 90% Georgia,serif;
			}
		</style>

		<!--[if lt IE 9]>
			<script src="js/lib/respond.min.js"></script>
		<![endif]-->
	</head>
	<body>
		<!--[if lt IE 7]>
			<p class="browsehappy">You are using an <h5>outdated</h5> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
		<![endif]-->

		<div class="container">
			<div class="site-header">
				<h1 class="text-center">Учебный сайт "MitM"</h1>
			</div>
			<hr>
			<div class="page-header">
				<h1 class="text-center">Лабораторная работа <small>&laquo;Человек посередине&raquo;</small></h1>
			</div>

			<div class="row">
				<div class="col-md-3">
					<ul class="nav nav-pills nav-stacked">
						<li><a href=".">Главная</a></li>
						<li class="active">
							<a href="#">Методическое пособие</a>
							<ul class="nav nav-pills nav-stacked nav-inner">
								<li><a href="#varieties">Разновидности атаки типа «Человек посередине»</a></li>
								<li><a href="#vulnerability">Уязвимости атаки типа «Человек посередине»</a></li>
								<li><a href="#find">Обнаружение атаки типа «Человек посередине»</a></li>
								<li><a href="#defence">Способы защиты от атаки типа «Человек посередине»</a></li>
								<li><a href="#sandbox">Песочница</a></li>
								<li><a href="#materials">Дополнительные материалы</a></li>
							</ul>
						</li>
						<li><a href="materials.html">Материалы</a></li>
						<li><a href="task.html">Ход выполнения работы</a></li>
						<li><a href="question.html">Контроль знаний</a></li>
						<li><a href="https://github.com/vyalovaa/mitm-lab" target="_blank">Исходный код</a></li>
					</ul>
				</div>

				<div class="col-md-9">
					<div class="well well-lg">
						<p>
							«Человек посередине» (англ. <i>Man in the middle</i>) — термин, обозначающий ситуацию, когда злоумышленник способен перехватывать, 
							перенаправлять и изменять по своей воле сообщения, которыми обмениваются пользователи, причём ни один из них не может догадаться о присутствии злоумышленника в канале.
						</p>
						<p>						
							«Человек посередине» - это метод компрометации канала связи, при котором злоумышленник, подключившись к каналу между контрагентами, 
							выполняет активное вмешательство в протокол передачи, навязывая ложную, искажая или удаляя информацию.
						</p>
						<p>	
							Атака типа «Человек посередине» обычно начинается с прослушивания канала связи и заканчивается попыткой злоумышленника извлечь выгоду из перехваченного сообщения, 
							подменить сообщение, перенаправить его на внешний ресурс.
						</p>
						<p>	
							Пример: 
							<br>
							Объект A передает объекту B некоторую информацию. Объект C обладает знаниями о структуре и свойствах протоколов, планирует перехватить эту информацию. 
							Чтобы совершить атаку объект С "представляется" объекту А - объектом В, а объекту В — объектом А. Таким образом, объект А отправляя информацию объекту В, 
							неосознанно посылает её объекту С. В свою очередь объект С, получив информацию и совершив с ней некоторые действия пересылает данные настоящему объекту В. 
							Объект В, ничего не подозревая, считает, что информация была получена напрямую от объекта А. Пример представлен на рисунке 1.
							<br>
							<!--<img src = "img/mitm.jpg">-->
							<figure class="img">
								<img alt="человек посередине" src="img/mitm.jpg" height="50%" width="50%">
								<figcaption>Рис.1 Пример атаки типа «Человек посередине»</figcaption>
							</figure>
							

						</p>
						
						<h4 id="varieties">Разновидности атаки типа «Человек посередине»</h4>
						<p>
						<h5>Session hijacking</h5> 
						<br>
							Атака угон сеанса состоит из эксплуатации механизма управления веб-сессии, которая обычно управляется токеном сеанса.
							Поскольку HTTP коммуникации использует множество различных TCP соединений, веб-серверу необходим способ распознавать соединения каждого пользователя. 
							Наиболее полезный метод зависит от токена, который веб-сервером отправляется в браузер клиента после успешной аутентификации клиента. 
							Токен сеанса, как правило, состоит из строки переменной ширины и ее можно использовать по-разному, как в URL, так и в заголовке HTTP запроса - cookie, 
							а также в других частях заголовка запроса HTTP, или еще в теле HTTP запроса. Угон сеанса представлен на рисунке 2.
							<figure class="img">
								<img alt="session hijacking" src="img/session_hijacking.jpg" height="45%" width="45%">
								<figcaption>Рис.2 Угон сеанса</figcaption>
							</figure>
							Атака угон сеанса компрометирует токен сеанса путем кражи или предсказания правильного токена сеанса, для получения несанкционированного доступа к веб-серверу
						</p>
						<p>
						<h5>HTTP session hijacking</h5> 
						<br> 
							Угон HTTP сеанса предполагает получение SESSION ID, который является уникальным идентификатором HTTP-сессии. 
							Идентификатор сеанса можно найти в трех местах:
							<br>
							<ul>
								<li>В URL полученном браузером для запроса HTTP GET.</li>
								<li>С помощью куки, которые будут храниться в компьютере клиентов.</li>
								<li>В полях формы.</li>
							</ul>	
							Угон HTTP сеанса представлен на рисунке 3. 
							<figure class="img">
								<img alt="HTTP session hijacking" src="img/http_session_hijacking.jpg" height="50%" width="50%">
								<figcaption>Рис.3 Угон HTTP сеанса</figcaption>
							</figure>
						</p>
						<p>
						<h5>TCP hijacking или TCP session hijacking</h5> 
						<br> 
							При создании TCP сеанса клиент начинает посылать SYN-пакет с значением sequence number. 
							Этот номер используется для обеспечения передачи пакетов в хронологическом порядке. Он увеличивается на единицу с каждым пакетом. 
							Обе стороны соединения ждут пакет с заданным sequence number. Первый sequence number для двух сторон определяется случайным образом. 
							Сервер отвечает пакетом SYN/ACK, который содержит sequence number клиента + 1, а также собственный sequence number. 
							Клиент подтверждает все пакетом ACK, включая  sequence number сервера + 1, после чего устанавливается сеанс. 
							Пример создания TCP сеанса представлен на рисунке 4.
							<figure class="img">
								<img alt="TCP session hijacking" src="img/tcp_session_hijacking.jpg" height="40%" width="40%">
								<figcaption>Рис.4 Установление TCP сеанса</figcaption>
							</figure>
							<br>
							Чтобы угнать сеанс, надо ждать пакета и использовать информацию, находящуюся в нем: IP-адрес источника, IP адрес получателя, 
							порт источника, порт получателя, и sequence number. С помощью этих данных можно создать собственный пакет и отправить его сразу к серверу. 
							Сервер принимает его и увеличивает ожидаемый sequence number. Когда следующий пакет от реального клиента приходит на сервер, то он отбрасывается, 
							так как устарел, поэтому клиент десинхронизирован и теряет связь.
						</p>
						<p>
						<h5>UDP session hijacking</h5> 
						<br> 
							Поскольку UDP не использует последовательные и синхронизирующие пакеты; угнать сеанс UDP проще, чем TCP. 
							Угонщик должен просто подделать ответ сервера клиенту, прежде чем сервер может ответить. 
							Если используется прослушивание канала, то будет легче контролировать генерацию трафика со стороны сервера и, таким образом, 
							ограничивать ответ сервера клиенту. <ins>Угон UDP сеанса представлен на рисунке 5.</ins>
							<figure class="img">
								<img alt="UDP session hijacking" src="img/udp_session_hijacking.jpg" height="45%" width="45%">
								<figcaption>Рис.5 Угон UDP сеанса</figcaption>
							</figure>

						</p>
						
						<h4 id="vulnerability">Уязвимости атаки типа «Человек посередине»</h4>
						<p>
							<h5>Уязвимость протокола ARP</h5>
							<br>
							ARP-spoofing (ARP-poisoning) — техника сетевой атаки, которая применяется в Ethernet, но возможна и в других протоколах, использующих ARP. 
							Она основана на использовании недостатков протокола ARP и позволяет перехватить трафик между хостами, расположенными в пределах одного широковещательного домена. 
							Она относится к числу spoofing атак.
							
						<p>
							До выполнения ARP-spoofing'а в ARP-таблице узлов A и B существуют записи с IP и MAC адресами друг друга. Обмен информацией производится между узлами A и B. (зелёная стрелка)
							В ходе выполнения ARP-spoofing'а компьютер C, который выполняет атаку, отправляет ARP-ответы:
							узлу A: с IP адресом узла B и MAC адресом узла C;
							узлу B: с IP адресом узла A и MAC адресом узла C.
							Так как компьютеры поддерживают самопроизвольный ARP (gratuitous ARP), то они могут модифицировать собственные ARP-таблицы и поместить туда записи, 
							которые вместо настоящих MAC адресов узлов A и B поставят  MAC адрес узла C. (красные стрелки). 
							Наглядный пример arp-spoofing’а изображен на рисунке 6.
							<figure class="img">
								<img alt="arp spoofing" src="img/arp_spoofing.jpg" height="45%" width="45%">
								<figcaption>Рис.6 Пример работы arp-spoofing</figcaption>
							</figure>
							После выполнения атаки, узел A хочет передать пакет узлу B, он находит в ARP-таблице запись (в которой уже записан МАС узла C) и определяет из неё MAC адрес получателя. 
							Отправляя по этому MAC адресу, пакет приходит узлу C вместо получателя. Узел C затем ретранслирует пакет тому, кому он был предназначен — т.е. узлу B. (синие стрелки).
						</p>	
						<p>
							<h5>Уязвимость протокола SSL</h5>
						<br>
							Если нельзя «влезть» в защищённое соединение, то почему не установить два разных: одно между клиентом и злоумышленником, 
							который притворяется сервером, второе между злоумышленником и сервером.
						</p>
						<p>
							От этого алгоритм Диффи-Хелмана не защищён. Однако SSL, в отличии от Диффи Хелмана, требует аутентификацию сервера, поэтому данный подход бесполезен. 
							Во время установления соединения, клиент ждёт от сервера аутентификации, которая обязательна при использовании SSL. 
							Но вместо сервера клиент будет соединён с злоумышленником, не владеющим цифровым сертификатом, который соответствует имени сайта.
							<br>
							Существует два способа решения проблемы отсутствующего сертификата:
							<ul>
								<li>Первый способ – это создание необходимого «самоподписанного» сертификата самостоятельно. 
									Но система цифровых сертификатов требует возможности проверки состоятельности сертификата. 
									Для этого используются «удостоверяющие центры» (Certification authority, CA или УЦ). 
									Они могут подписать сертификат сайта (и не только), а также подписать сертификат других УЦ. 
									Сертификаты корневых УЦ – их мало – внесены в браузер разработчиками. 
									Браузер считает сертификат подлинным, если только он находится в конце цепочки сертификатов, 
									которая начинается с одного из УЦ (каждый следующий сертификат подписан предыдущим в цепочке).
								</li>
								<li>Второй способ – это получение у УЦ сертификата для нужного сайта и использовать этот сертификат для атаки. 
									Этот способ не подходит из-за того, что в каждом сертификате сайта указан домен, для которого он выдавался. 
									Если домен, указанный в адресной строке, не совпадет с доменом, указанным в сертификате, то браузер начнёт бить тревогу.
								</li>
							</ul>	
							<h5>SSL Strip</h5>
							<br>
								Техника, преобразующая https ссылки в http. Таким образом заставляет цель отправлять данные в не защищенном виде. 
								Подмена происходит только в открытом трафике. Может самостоятельно проксировать соединения до оригинального https ресурса.
						</p>
						<p>
							<h5>Уязвимость протокола SSH</h5>
							<br>
							Злоумышленник получает данные авторизации пользователя и записывает в лог весь сеанс связи, запуски команд и результаты их выполнения.
							Чтобы это осуществить, трафик жертвы перенаправляетcя на свой собственный ssh сервер, и если авторизация проходит успешно, 
							соединение проксируется до настоящего сервера.
							Если терминальная программа жертвы имеет фингерпринт ключа от удаленного сервера, 
							хранящийся в кеше, то будет выдано предупреждение о изменении ключа в момент авторизации.
						</p>
						<p>
							<h5>Уязвимость протокола WPAD</h5>
							<br>
							WPAD — Web Proxy Auto-Discovery. Протокол автоматического получения настроек прокси в локальной сети.  Этот протокол поддерживается многими веб-браузерами и 
							рядом других приложений. Сущность его работы состоит в том, что если клиент использует DHCP для получения IP адреса, 
							то и за URL с настройкой прокси он обращается к своему DHCP серверу. Если DHCP не настроен на выдачу WPAD конфигурации, если в сети не используется DHCP, 
							то клиент попробует дать разрешение сетевому имени вида wpad.localdomain, используя DNS. Если данного имени не найдено, 
							то делается последняя попытка поиска имени 'WPAD' через NetBios. В случае, если после последней попытки имя не найдено, клиент пробует соединиться напрямую, 
							но в том случае, если кто-то сказал, что имеет имя 'WPAD', то клиент соединится по 80 порту на IP адрес ответившего хоста и попытается загрузить файл wpad.dat, 
							в котором должны быть настройки прокси.
						</p>
						<p>
							Сразу после начала своего существования WPAD стал дыркой в безопасности, за-за того, 
							что он позволяет легко перехватить трафик, выдавая себя за легитимный прокси сервер. 
							Эта атака не приобрела большой известности, даже несмотря на то, что эта уязвимость существует давно.
						</p>
						<p>
							<h5>Уязвимость протокола HTTP</h5>
							<br>
							Кроме пассивного прослушивания, атаки типа «Человек посередине» могут предоставить большие возможности 
							(например, выполнение произвольного кода на стороне жертвы). При проведении атаки типа «Человек посередине», 
							злоумышленник перенаправляет трафик жертвы таким образом, что трафик идет через него, и в данном случае, может изменять пакеты. 
							Таким образом, при запросе какого-нибудь flashplayer.exe, можно подставить любой другой исполняемый файл (к примеру, bindshell код) и 
							после запуска получить возможность исполнения команд.
						</p>
						<h4 id="find">Обнаружение атаки типа «Человек посередине»</h4>
						<p>
							Чтобы обнаружить атаку типа «Человек посередине», необходимо проанализировать сетевой трафик.
							<br>
							Для обнаружения атаки по SSL, нужно обратить внимание на следующие параметры:
							<ul>
								<li>IP адрес сервера;</li>
								<li>DNS-сервер;</li>
								<li>X.509 сертификат сервера
									<ul>
										<li>Подписан ли сертификат самостоятельно;</li>
										<li>Подписан ли сертификат УЦ;</li>
										<li>Был ли сертификат аннулирован;</li>
										<li>Менялся ли недавно сертификат;</li>
										<li>Получали ли другие клиенты такой же сертификат;</li>
									</ul>
								</li>	
							</ul>
						<p>
							Для обнаружения отравления ARP кэша нужен мониторинг сетевого трафика. В этом плане может помочь система обнаружения вторжений, 
							например, Snort, или с помощью утилит, специально созданных для этой задачи, например, xARP. 
							Это возможно, когда речь идет только об одном узле, но может быть довольно сложным при работе с целыми сегментами сети. 
						</p>
						<p>
							Для обнаружения атаки по SSL необходимо убедиться в том, что используется защищенное HTTPS подключение. 
							Когда выполняется атака типа «Человек посередине» по SSL, она убирает все аспекты защиты подключения, что можно увидеть в браузере. 
							Если, зайдя в свой банковский аккаунт через интернет в браузере видно, что это простое HTTP подключение, то высока вероятность того, что что-то не так. 
							Независимо от модели браузера, необходимо уметь различать защищенные подключения и незащищенные. 
						</p>
						
						
						<h4 id="defence">Способы защиты от атаки типа «Человек посередине»</h4>
						<p>
							Если рассматривать отравление ARP кэша с точки зрения защищающейся стороны, то пользователь находится в менее выгодном положении. 
							Процесс ARP происходит на заднем плане, и поэтому практически нет возможности контролировать его напрямую. 
							Не существует единого решения, но предупредительные меры можно предпринять.
							
						</p>
						<p>
							Атака ARP Cache Poisoning является действенным способом атаки только при попытке перехватить трафик между узлами в одной локальной сети. 
							Единственная причина бояться такой атаки – это если локальное устройство в сети было взломано, доверенный пользователь имеет злоумышленные намерения, 
							или кто-то смог внедрить не доверенное устройство в сеть. 
						</p>
						<p>
							<i>Жесткое программирование ARP кэша.</i>
							Динамическую природу ARP запросов и ответов можно сделать менее динамической. 
							Это вариант, поскольку узлы на базе Windows позволяют добавлять статические записи в ARP кэш. 
							<br>
							Просматривать ARP кэш узла Windows можно, если открыть командную строку и ввести следующую команду:
							<pre><ul><li><code>arp -a.<code></li></ul></pre>
							Можно добавлять записи в этот список, используя команду:
							<pre><ul><li><code>arp –s  <IP ADDRESS> <MAC ADDRESS>.<code></li></ul></pre>
							В ситуациях, когда конфигурация локальной сети не часто меняется, можно создать статические записи ARP. 
							После этого устройства всегда будут полагаться на свой локальный ARP кэш, а не на ARP запросы и ответы.
							<br>
							Однако, при выполнении команды arp –s  <IP ADDRESS> <MAC ADDRESS> может быть отказано в доступе, поэтому лучше пользоваться следующей командой:
							<pre><ul><li><code>netsh interface ipv4 add neighbors “Network Name” “IP ADDRESS” “MAC ADDRESS”.<code></li></ul></pre>
							Имя сети можно посмотреть в «Центре управления сетями и общим доступом» в подменю «Изменение параметров адаптера».
						</p>
						<p>
							<i>Использование СОВ.</i>
							Системы обнаружения вторжений, если их правильно развернуть и настроить, могут быстро обнаруживать большинство форм отравления ARP кэша и подделки DNS.
							<i>Использование DNSSEC.</i>
							DNSSEC – это более новая альтернатива протоколу DNS, которая использует записи DNS с цифровой подписью для проверки подлинности ответов на запрос. 
							DNSSEC еще не применяется широко, но принята как будущее DNS.
						</p>		
						<p>
							Также необходимо убедиться в том, что используется <i>защищенное HTTPS подключение<i>.
						</p>

						</p>
						<h4 id="sandbox">Песочница</a></h4>
						<p>
							sandbox here (^.^)
							<pre>tadadadam</pre>
						</p>
						
						
					
						<!--
						<p>
							SQL-инъекция (англ. <i>SQL injection</i>) — распространённая атака на веб-сайты и приложения,
							работающие с <abbr title="база данных">БД</abbr>. Атака возможна в том случае, когда входные
							данные, получаемые от пользователя, некорректно или недостаточно фильтруются перед использованием
							в запросах к БД. Это позволяет внедрять во входные данные произвольный SQL-код, меняющий логику
							работы запроса.
						</p>						
							Пример уязвимого кода на PHP:
<pre><code><font color="#009900">$username</font> <font color="#990000">=</font> <font color="#009900">$_GET</font><font color="#990000">[</font><font color="#FF0000">'username'</font><font color="#990000">];</font>
<font color="#009900">$result</font> <font color="#990000">=</font> <b><font color="#000000">mysql_query</font></b><font color="#990000">(</font><font color="#FF0000">"SELECT * FROM users WHERE username = '$username'"</font><font color="#990000">);</font></code></pre>
						</p>
						
						<div class="panel panel-info">
							<div class="panel-heading">Демонстрация</div>
							<div class="panel-body">
								<input type="text" value="1234" class="form-control" id="demo2-field">
								<pre><code>SELECT author, title, text FROM news WHERE id = <span class="demo-slot" id="demo2-slot"></span></code></pre>
							</div>
						</div>

						<p>
							(например, <tt>NULL</tt>).
						</p>

						<h4 id="blind">Слепая SQL-инъекция</h4>

						<div class="callout callout-info">
							Различные реализации СУБД могут предоставлять другие способы объединения строк.  За подробной информацией
							обращайтесь к документации по СУБД.
						</div>
						
						<h4 id="materials">Дополнительные материалы</h4>
						<ol>
							<li><a href="http://???.ru">???</a></li>
							<li><a href="http://???.com/">???</a></li>
						</ol>
						-->
					</div>
				</div>
			</div>
		</div>

		<script src="js/lib/jquery-1.10.2.min.js"></script>
		<script>
			$(function() {
				$('#demo1-slot').html($('#demo1-field').val());
				$('#demo2-slot').html($('#demo2-field').val());
				$('#demo1-field').keyup(function() {
					$('#demo1-slot').html($(this).val());
				});
				$('#demo2-field').keyup(function() {
					$('#demo2-slot').html($(this).val());
				});
			});
		</script>
	</body>
</html>
